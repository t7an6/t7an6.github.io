[{"title":"Hello World","url":"/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\n# Quick Start\n# Create a new post\n$ hexo new &quot;My New Post&quot;\nMore info: Writing\n# Run server\n$ hexo server\nMore info: Server\n# Generate static files\n$ hexo generate\nMore info: Generating\n# Deploy to remote sites\n$ hexo deploy\nMore info: Deployment\n"},{"title":"My New Post","url":"/My-New-Post/","content":"这个界面用于测试个人博客\n"},{"title":"热烈庆祝开了个新坑","url":"/poster/","content":"搞个博客搞了大半夜，想来自己这快两年的大学生涯，也是一事无成吧 T_T。也是有种预感\n，感觉要考研了，为了督促自己也是突然想写点东西了，就开了一个这个专题。如果你看到这个文章，也请原谅我有些地方的无知，毕竟蜀黍我呀，也是玩了两年捏。\n谢谢你们陪我。\nps: 现在这个博客只有我发文章的权利哈哈。还有很多配置没有完成，后续有时间会补上的。\n","tags":["个人杂谈"]},{"title":"'复习排序算法'","url":"/%E5%A4%8D%E4%B9%A0%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","content":"# 前言\n现在我只是初步的捡起来当初学数据结构的时候没学的排序算法 T_T。对于博主而且现在还没有上算法与设计这门课，如果有相关的设计内容会放在添加页。\n# 算法内容\n本篇选取现在我能理解的一些算法，以及一些我想了解的排序。\n# 插入算法\n对于这个算法，就是把除了第一个数以后的数字，从前往后的选取，然后从这个数开始往前依次比较。（两个不一样的顺序确实容易把人搞晕。这里给一个例子：4123 这个数列，第一个 4 不管，从 1 开始，判断前面一个数 4，比 1 大，那么 1 插入 4 前面变成 1423，对于后面两个数依此类推）。由于比较简单代码请自行搜索。\n# 希尔排序\nps:写到这里的时候博主电脑被干崩了，导致直接系统重装了。不知道是不是楼主fgo脚本挂多了，还是最近的联想系统本身的问题（搜的时候评论区里面全是联想用户捏）。\n接下来是正题，关于 shellsort，这其实就是一个特殊的插入算法，对于每个间隔 gap 的数字规划为一组，然后组内排序。\n# 选择排序\n# 搁置说明\n没想到事情有点多，这个排序算法有点没时间一点一点搞了。现在先做搁置处理，有时间再来吧（其实在学习算法与分析一些方法的时候也会使用一些排序算法，到时候会给上链接）。\n","tags":["算法与分析","c语言","考研数据结构"]},{"title":"分治算法","url":"/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/","content":"在这一节我将开始讲述一些我在学习算法分析时候的体验与想法，以及归纳一些方法。\n# 前言\n其实在学习这个的时候楼主先看了会回溯算法，感觉这个方法实在暴力，于是就去找学校的课件去了。然后发现了童老师和许老师的课件都是从 merge（分治）开始讲起的。（ps：在这之前的第一节课上老师讲到了最大团问题作为引导，但是楼主道行太浅了，没有理解捏）。\n# 基本原理\n这个方法我想用归并排序作为例子。这个排序方法是将一个大数组不断分成小的数组最后合并到一起的算法。\n由此引出了分治算法的基本原理\n\n\n选择一个可以复用的方法\n将问题不断划分直至划分到简单形式\n解决问题，然后合并。不断重复此步直到无法重复。\n\n\n这个方法比较抽象，在划分这上面需要我们自己确定如何划分到最小。并且解决方法也与划分息息相关。并且我在一开始对于 c 语言的合并并不清楚，但是在做了几个题之后才想起来 memcpy 这个函数（os 真是白学了）。而且这里面对于递归的使用比较多，当然也会有非递归的题目（碰上了真是想破头都想不出来）。\n在下面我会列出我写过的一些题目，以及一些方法。不过肯定不如一些大神写的清楚，要想完善自己的体验请移步解答区。\n\npow(x,n)\n排序数组\n\n这个题目可以通用一些排序算法，这里我用的归并排序。\n\n\n多数元素\n最大子数组和\n漂亮数组\n\n\n# 题目过程讲解\n\n前言部分\n\n其实分治的过程和递归很大程度上是相似的，但是分出小组，解决问题，然后归并成较大组，然后再合并至解决原来的问题，这个过程思想才是分治想要表达的。递归只是其中一种方法罢了。\n# pow(x,n)\n这个题目就是我提到的非递归解决之一，在遇见这个题之前博主一直都认为分治就是不断递归的过程。在这里我才开始修正自己的想法。那么来让我们想想这个题怎么做。\n在一个数字的幂运算，像：292^929 这样，我们来看一下这个如何分治。像之前的归并排序一样，我们肯定是想分开这个数字。好，那么我们来看一下如何分？正常肯定会想成对某个数字除以 2 吧，在这里就理所应当的对指数除 2 了，那么我们来看一下 9 的 2 进制，1001，刚好就是23+212^3+2^123+21。那么我们就明确了对于这样一个数字快速计算我们就只在对应指数 2 进制位数置位的时候乘上对应位数的指数级数就行了，这样就避免了循环 n 的问题，转变成加法 (时间效率 Olog (n)) 计算。\n#define Ep 1e-10double myPow(double x, int n) &#123;    if(fabs(x)&lt;Ep)    return 0;    if(x==1)&#123;        return 1;    &#125;    double res = 1;    long long y=n;    if(n &lt; 0)&#123;        x = 1/x;        y = -y;    &#125;    while(y)&#123;        if(y &amp; 1 == 1)            res *=x;        x *= x;        y =y &gt;&gt; 1;    &#125;    return res;&#125;\n# 排序数组\n请参考上面或自行搜索（绝对不是博主偷懒）。\n# 多数元素 &amp;&amp; 最大子数组和\n这两个问题比较相似，所以放在一起将。\n多数元素就是将数组前后不断划分，直到分到的长度唯一的时候开始返回归并，一开始的时候多数元素就是返回的元素，然后合并后检查之前子数组中的多数元素是否还是多数（只用检查众数哦），相同的数字同为多数元素。\n最大子数组和也一样，只不过分到最小的时候返回值，在归并后，要多计算跨过中点值的前后数组的一个和，要多写一个辅助函数计算。\n这里仅给出后一个问题解答。\nint midSubArray(int *nums,int min,int mid,int max)&#123;    long left_sum=-999999;    long right_sum=-9999999;        int sum=0;    for(int i=mid;i&gt;=min;i--)&#123;        sum+=nums[i];        if(sum&gt;=left_sum)            left_sum=sum;    &#125;    sum=0;    for(int i=mid+1;i&lt;=max;i++)&#123;        sum+=nums[i];        if(sum&gt;=right_sum)            right_sum=sum;    &#125;    return left_sum+right_sum;&#125;int maxSubArray(int* nums, int numsSize) &#123;    if(numsSize==1)    return *nums;    int min=0,max=numsSize-1;    int q=min+(max-min)/2;    long loResult=maxSubArray(nums+min,q-min+1);    long hiResult=maxSubArray(nums+q+1,max-q);    long midResult=midSubArray(nums,min,q,max);    long maxSum=0;    if(loResult&gt;hiResult)        maxSum=loResult;    else        maxSum=hiResult;    maxSum=maxSum&gt;midResult?maxSum:midResult;    return maxSum;&#125;\n# 漂亮数组\n这个题也是非递归，主要还是看个人的观察能力。不过博主没时间写了，仅给出代码，请自行搜索解答\nint* beautifulArray(int n, int* returnSize) &#123;        int *res=(int*)malloc(sizeof(int));        res[0]=1;        int curCount=1;        int tempNum=0;        for(;curCount&lt;n;curCount=tempNum)&#123;            int* temp=(int*)malloc(n*sizeof(int));            tempNum=0;            for(int i=0;i&lt;curCount;i++)&#123;                int oddNum=res[i]*2-1;                if(oddNum&lt;=n)                    temp[tempNum++]=oddNum;            &#125;            for(int i=0;i&lt;curCount;i++)&#123;                int evenNum=res[i]*2;                if(evenNum&lt;=n)                    temp[tempNum++]=evenNum;            &#125;            free(res);            res=temp;                    &#125;        *returnSize=n;        return res;&#125;\n","tags":["算法与分析","c语言"]}]